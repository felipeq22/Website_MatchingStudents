{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ba127e1f-0894-496a-9d31-36f1c122ea21",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import pulp\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from collections import defaultdict "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d4243176-d671-4c5c-b2ba-e0cde9f606a6",
   "metadata": {},
   "source": [
    "Sets and Parameters\n",
    "\n",
    "SS\n",
    "S: Set of students\n",
    "\n",
    "CC\n",
    "C: Set of courses\n",
    "\n",
    "PsP_s\n",
    "Ps​: Set of program-specific courses for student ss\n",
    "s\n",
    "\n",
    "Decision Variables\n",
    "\n",
    "Xsc∈{0,1}X_{sc} \\in \\{0, 1\\}\n",
    "Xsc​∈{0,1}:\n",
    "\n",
    "\n",
    "Xsc=1X_{sc} = 1\n",
    "Xsc​=1 if student ss\n",
    "s is assigned to course cc\n",
    "c\n",
    "Xsc=0X_{sc} = 0\n",
    "Xsc​=0 otherwise\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Utility Function\n",
    "Usc=max⁡(10−ranksc,1)U_{sc} = \\max(10 - \\text{rank}_{sc}, 1) \n",
    "Usc​=max(10−ranksc​,1) \n",
    "\n",
    "Objective Function \n",
    "\n",
    "Maximize∑s∈S∑c∈CUsc⋅Xsc\\text{Maximize} \\sum_{s \\in S} \\sum_{c \\in C} U_{sc} \\cdot X_{sc}\n",
    "Maximize∑s∈S​∑c∈C​Usc​⋅Xsc​ \n",
    "\n",
    "\n",
    "Constraints\n",
    "1. Mandatory Course Constraint\n",
    "∀s∈S,∀c∈Ps:c is mandatory\\forall s \\in S, \\forall c \\in P_s : c \\text{ is mandatory}\n",
    "∀s∈S,∀c∈Ps​:c is mandatoryXsc=1X_{sc} = 1\n",
    "Xsc​=1\n",
    "2. Elective Course Limit Constraint\n",
    "∀s∈S\\forall s \\in S\n",
    "∀s∈S\\sum_{c \\in P_s : c \\text{ is elective}} X_{sc} = \\text{required_electives}_s\n",
    "\n",
    "3. Course Capacity Constraint\n",
    "∀c∈C\\forall c \\in C\n",
    "∀c∈C∑s∈SXsc≤capacityc\\sum_{s \\in S} X_{sc} \\leq \\text{capacity}_c\n",
    "∑s∈S​Xsc​≤capacityc​\n",
    "4. Binary Constraint\n",
    "∀s∈S,∀c∈C\\forall s \\in S, \\forall c \\in C\n",
    "∀s∈S,∀c∈CXsc∈{0,1}X_{sc} \\in \\{0, 1\\}\n",
    "Xsc​∈{0,1}\n",
    "\n",
    "Interpretation:-\n",
    "\n",
    "Maximizes total utility of course assignments\n",
    "Ensures mandatory courses are assigned\n",
    "Limits elective courses per student\n",
    "Respects course capacity constraints"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "060b0bf4-3e59-4606-b02c-dc56417468db",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Welcome to the CBC MILP Solver \n",
      "Version: 2.10.3 \n",
      "Build Date: Dec 15 2019 \n",
      "\n",
      "command line - /Applications/anaconda3/envs/python313/lib/python3.13/site-packages/pulp/apis/../solverdir/cbc/osx/i64/cbc /var/folders/00/bhmglhlx427341n1cdxtx73w0000gn/T/8a271562a138423aa4fd8ae3d16faf27-pulp.mps -max -timeMode elapsed -branch -printingOptions all -solution /var/folders/00/bhmglhlx427341n1cdxtx73w0000gn/T/8a271562a138423aa4fd8ae3d16faf27-pulp.sol (default strategy 1)\n",
      "At line 2 NAME          MODEL\n",
      "At line 3 ROWS\n",
      "At line 35 COLUMNS\n",
      "At line 308 RHS\n",
      "At line 339 BOUNDS\n",
      "At line 417 ENDATA\n",
      "Problem MODEL has 30 rows, 77 columns and 98 elements\n",
      "Coin0008I MODEL read with 0 errors\n",
      "Option for timeMode changed from cpu to elapsed\n",
      "Continuous objective value is 133 - 0.00 seconds\n",
      "Cgl0004I processed model has 5 rows, 15 columns (15 integer (15 of which binary)) and 15 elements\n",
      "Cutoff increment increased from 1e-05 to 0.9999\n",
      "Cbc0038I Initial state - 0 integers unsatisfied sum - 0\n",
      "Cbc0038I Solution found of -133\n",
      "Cbc0038I Before mini branch and bound, 15 integers at bound fixed and 0 continuous\n",
      "Cbc0038I Mini branch and bound did not improve solution (0.03 seconds)\n",
      "Cbc0038I After 0.03 seconds - Feasibility pump exiting with objective of -133 - took 0.00 seconds\n",
      "Cbc0012I Integer solution of -133 found by feasibility pump after 0 iterations and 0 nodes (0.03 seconds)\n",
      "Cbc0001I Search completed - best objective -133, took 0 iterations and 0 nodes (0.03 seconds)\n",
      "Cbc0035I Maximum depth 0, 0 variables fixed on reduced cost\n",
      "Cuts at root node changed objective from -133 to -133\n",
      "Probing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Gomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Knapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Clique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "MixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "FlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "TwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "ZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "\n",
      "Result - Optimal solution found\n",
      "\n",
      "Objective value:                133.00000000\n",
      "Enumerated nodes:               0\n",
      "Total iterations:               0\n",
      "Time (CPU seconds):             0.00\n",
      "Time (Wallclock seconds):       0.03\n",
      "\n",
      "Option for printingOptions changed from normal to all\n",
      "Total time (CPU seconds):       0.00   (Wallclock seconds):       0.04\n",
      "\n",
      "Course matching completed. Results saved to student_course_matching.csv\n"
     ]
    }
   ],
   "source": [
    "def load_data():\n",
    "    \"\"\"Load necessary CSV files for course matching.\"\"\"\n",
    "    # Load CSV files\n",
    "    course_data = pd.read_csv('course.csv')\n",
    "    student_data = pd.read_csv('student.csv')\n",
    "    elective_capacity_data = pd.read_csv('elective_capacity.csv')\n",
    "    elective_preference_data = pd.read_csv('elective_preference.csv')\n",
    "    \n",
    "    # Strip whitespace from column names\n",
    "    course_data.columns = course_data.columns.str.strip()\n",
    "    student_data.columns = student_data.columns.str.strip()\n",
    "    elective_capacity_data.columns = elective_capacity_data.columns.str.strip()\n",
    "    elective_preference_data.columns = elective_preference_data.columns.str.strip()\n",
    "    \n",
    "    # Strip whitespace from string columns\n",
    "    for df in [course_data, student_data, elective_capacity_data, elective_preference_data]:\n",
    "        for col in df.select_dtypes(include=['object']).columns:\n",
    "            df[col] = df[col].str.strip()\n",
    "    \n",
    "    return course_data, student_data, elective_capacity_data, elective_preference_data\n",
    "\n",
    "def optimize_course_matching():\n",
    "    \"\"\"\n",
    "    Optimize course matching for students\n",
    "    \"\"\"\n",
    "    # Load data\n",
    "    course_data, student_data, elective_capacity_data, elective_preference_data = load_data()\n",
    "    \n",
    "    # Create PuLP model\n",
    "    model = pulp.LpProblem(\"Course_Matching\", pulp.LpMaximize)\n",
    "    \n",
    "    # Prepare data\n",
    "    students = student_data['student_id'].tolist()\n",
    "    courses = course_data['course_id'].tolist()\n",
    "    \n",
    "    # Decision variables\n",
    "    # X[s,c] = 1 if student s is assigned to course c, 0 otherwise\n",
    "    X = pulp.LpVariable.dicts(\"X\", \n",
    "                             [(s, c) for s in students for c in courses], \n",
    "                             cat=pulp.LpBinary)\n",
    "    \n",
    "    # Objective function: utility based on preference ranking\n",
    "    def calculate_utility(rank):\n",
    "        return max(10 - rank, 1)\n",
    "    \n",
    "    # Preference utility\n",
    "    preference_utility = []\n",
    "    for _, pref in elective_preference_data.iterrows():\n",
    "        student_id = pref['student_id']\n",
    "        course_id = pref['course_id']\n",
    "        utility = calculate_utility(pref['preference_rank'])\n",
    "        preference_utility.append(utility * X[(student_id, course_id)])\n",
    "    \n",
    "    # Set objective: maximize preference utility\n",
    "    model += pulp.lpSum(preference_utility), \"Preference Utility\"\n",
    "    \n",
    "    # Constraints\n",
    "    # 1. Mandatory course constraints\n",
    "    for _, student in student_data.iterrows():\n",
    "        student_id = student['student_id']\n",
    "        program_id = student['program_id']\n",
    "        \n",
    "        # Identify mandatory courses for this student's program\n",
    "        mandatory_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 1)\n",
    "        ]['course_id'].tolist()\n",
    "        \n",
    "        # Ensure all mandatory courses are assigned\n",
    "        for course_id in mandatory_courses:\n",
    "            model += X[(student_id, course_id)] == 1, f\"Mandatory_{student_id}_{course_id}\"\n",
    "    \n",
    "    # 2. Elective course constraints\n",
    "    for _, student in student_data.iterrows():\n",
    "        student_id = student['student_id']\n",
    "        program_id = student['program_id']\n",
    "        required_electives = student['required_electives']\n",
    "        \n",
    "        # Identify elective courses for this student's program\n",
    "        elective_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 0)\n",
    "        ]['course_id'].tolist()\n",
    "        \n",
    "        # Ensure exact number of electives are assigned\n",
    "        if elective_courses:\n",
    "            model += pulp.lpSum(X[(student_id, c)] for c in elective_courses) == required_electives, f\"ElectiveLimit_{student_id}\"\n",
    "    \n",
    "    # 3. Elective course capacity constraints\n",
    "    for _, capacity in elective_capacity_data.iterrows():\n",
    "        course_id = capacity['course_id']\n",
    "        max_capacity = capacity['capacity']\n",
    "        \n",
    "        model += pulp.lpSum(X[(s, course_id)] for s in students) <= max_capacity, f\"ElectiveCapacity_{course_id}\"\n",
    "    \n",
    "    # Solve the model\n",
    "    model.solve()\n",
    "    \n",
    "    # Check solution status\n",
    "    if pulp.LpStatus[model.status] != 'Optimal':\n",
    "        print(\"Could not find an optimal solution.\")\n",
    "        return None\n",
    "    \n",
    "    # Extract results\n",
    "    results = []\n",
    "    for _, student in student_data.iterrows():\n",
    "        student_id = student['student_id']\n",
    "        program_id = student['program_id']\n",
    "        \n",
    "        # Find mandatory courses\n",
    "        mandatory_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 1)\n",
    "        ]\n",
    "        \n",
    "        # Find elective courses\n",
    "        elective_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 0)\n",
    "        ]\n",
    "        \n",
    "        # Track assigned courses\n",
    "        for _, course in mandatory_courses.iterrows():\n",
    "            if X[(student_id, course['course_id'])].value() > 0.5:\n",
    "                results.append({\n",
    "                    'student_id': student_id,\n",
    "                    'student_name': student_data[student_data['student_id'] == student_id]['name'].iloc[0],\n",
    "                    'course_type': 'Mandatory',\n",
    "                    'course_id': course['course_id'],\n",
    "                    'course_name': course['course_name']\n",
    "                })\n",
    "        \n",
    "        for _, course in elective_courses.iterrows():\n",
    "            if X[(student_id, course['course_id'])].value() > 0.5:\n",
    "                results.append({\n",
    "                    'student_id': student_id,\n",
    "                    'student_name': student_data[student_data['student_id'] == student_id]['name'].iloc[0],\n",
    "                    'course_type': 'Elective',\n",
    "                    'course_id': course['course_id'],\n",
    "                    'course_name': course['course_name']\n",
    "                })\n",
    "    \n",
    "    # Convert to DataFrame and export\n",
    "    results_df = pd.DataFrame(results)\n",
    "    results_df.to_csv('student_course_matching.csv', index=False)\n",
    "    \n",
    "    print(\"Course matching completed. Results saved to student_course_matching.csv\")\n",
    "    return results_df\n",
    "\n",
    "def main():\n",
    "    # Run optimization\n",
    "    optimize_course_matching()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b18de758-aaea-4ff1-a440-410b702cf314",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "0ec34a5c-6ddc-475e-a032-d9bd45ed9ae1",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "d782886b-9b98-4d2b-9e27-317939817243",
   "metadata": {},
   "source": [
    "\n",
    "Let S = {s₁, s₂, ..., sₙ} be the set of students\n",
    "Let C = {c₁, c₂, ..., cₘ} be the set of courses\n",
    "Let L = {l₁, l₂, ..., lₖ} be the set of lab sections\n",
    "Let P = {(s, c, l, r) | s ∈ S, c ∈ C, l ∈ L, r ∈ ℕ} be the set of lab preferences\n",
    "\n",
    "Decision Variables:\n",
    "\n",
    "Y[s,l] ∈ {0, 1}\n",
    "\n",
    "Y[s,l] = 1 if student s is assigned to lab section l\n",
    "Y[s,l] = 0 otherwise\n",
    "\n",
    "Preference Utility Function:\n",
    "u(r) : ℕ → ℝ⁺\n",
    "u(r) = max(10 - r, 1)\n",
    "Where:\n",
    "\n",
    "r is the preference ranking\n",
    "u(r) transforms the ranking into a utility score\n",
    "\n",
    "Objective Function:\n",
    "max Z = ∑[s∈S, l∈L, c∈C] u(r[s,c,l]) * Y[s,l]\n",
    "Constraints:\n",
    "\n",
    "Lab Assignment Constraint:\n",
    "∀s ∈ S, ∀c ∈ C with lab:\n",
    "∑[l∈L(c)] Y[s,l] = 1\n",
    "Lab Time Conflict Constraint:\n",
    "∀s ∈ S, ∀(l₁, l₂) ∈ L with conflicting times:\n",
    "Y[s,l₁] + Y[s,l₂] ≤ 1\n",
    "Lab Capacity Constraint:\n",
    "∀l ∈ L:\n",
    "∑[s∈S] Y[s,l] ≤ capacity[l]\n",
    "\n",
    "Detailed Description:\n",
    "\n",
    "Objective Function Breakdown:\n",
    "\n",
    "Maximizes the total utility of lab assignments\n",
    "Calculates utility for each student-course-lab combination\n",
    "Utility depends on the student's preference ranking\n",
    "Higher preference (lower rank) gives higher utility\n",
    "Minimum utility is 1, maximum is 9\n",
    "\n",
    "\n",
    "Preference Utility Function [u(r)]: \n",
    "Transforms preference ranking into a utility score\n",
    "For rank 1 (most preferred): u(1) = 9\n",
    "For rank 10 or higher: u(r) = 1\n",
    "Creates a non-linear utility scale that heavily rewards top preferences\n",
    "\n",
    "\n",
    "Constraints Explanation: \n",
    "Lab Assignment: Ensures each course with a lab gets exactly one lab section per student\n",
    "Time Conflict: Prevents assigning conflicting lab times to the same student\n",
    "Capacity: Ensures no lab section exceeds its maximum capacity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "id": "10d43f7f-4bd2-42b5-848e-7e70c743d05b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initial Data Analysis:\n",
      "Total students in course matching: 7\n",
      "Total lab time entries: 18\n",
      "Welcome to the CBC MILP Solver \n",
      "Version: 2.10.3 \n",
      "Build Date: Dec 15 2019 \n",
      "\n",
      "command line - /Applications/anaconda3/envs/python313/lib/python3.13/site-packages/pulp/apis/../solverdir/cbc/osx/i64/cbc /var/folders/00/bhmglhlx427341n1cdxtx73w0000gn/T/66259f15bc314921b5433f435e6f94ca-pulp.mps -max -timeMode elapsed -branch -printingOptions all -solution /var/folders/00/bhmglhlx427341n1cdxtx73w0000gn/T/66259f15bc314921b5433f435e6f94ca-pulp.sol (default strategy 1)\n",
      "At line 2 NAME          MODEL\n",
      "At line 3 ROWS\n",
      "At line 24 COLUMNS\n",
      "At line 172 RHS\n",
      "At line 192 BOUNDS\n",
      "At line 231 ENDATA\n",
      "Problem MODEL has 19 rows, 38 columns and 38 elements\n",
      "Coin0008I MODEL read with 0 errors\n",
      "Option for timeMode changed from cpu to elapsed\n",
      "Continuous objective value is 153 - 0.00 seconds\n",
      "Cgl0004I processed model has 0 rows, 0 columns (0 integer (0 of which binary)) and 0 elements\n",
      "Cbc3007W No integer variables - nothing to do\n",
      "Cuts at root node changed objective from -153 to -1.79769e+308\n",
      "Probing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Gomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Knapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "Clique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "MixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "FlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "TwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "ZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n",
      "\n",
      "Result - Optimal solution found\n",
      "\n",
      "Objective value:                153.00000000\n",
      "Enumerated nodes:               0\n",
      "Total iterations:               0\n",
      "Time (CPU seconds):             0.00\n",
      "Time (Wallclock seconds):       0.00\n",
      "\n",
      "Option for printingOptions changed from normal to all\n",
      "Total time (CPU seconds):       0.00   (Wallclock seconds):       0.00\n",
      "\n",
      "\n",
      "Solver Status: Optimal\n",
      "Course matching completed. Results saved to student_lab_matching.csv\n"
     ]
    }
   ],
   "source": [
    "def load_data():\n",
    "    \"\"\"\n",
    "    Load necessary data for lab matching optimization\n",
    "    \"\"\"\n",
    "    # Load CSV files\n",
    "    student_course_matching = pd.read_csv('student_course_matching.csv')\n",
    "    lab_time_data = pd.read_csv('lab_time.csv')\n",
    "    day_data = pd.read_csv('day.csv')\n",
    "    pre_lab_ele_man_data = pd.read_csv('pre_lab_ele_man.csv')\n",
    "    theory_time_data = pd.read_csv('theory_time.csv')\n",
    "    course_data = pd.read_csv('course.csv')\n",
    "    \n",
    "    # Strip whitespace from column names and data\n",
    "    for df in [student_course_matching, lab_time_data, day_data, \n",
    "               pre_lab_ele_man_data, theory_time_data, course_data]:\n",
    "        df.columns = df.columns.str.strip()\n",
    "        for col in df.select_dtypes(include=['object']).columns:\n",
    "            df[col] = df[col].str.strip()\n",
    "    \n",
    "    # Create day mapping\n",
    "    day_mapping = dict(zip(day_data['id_day'], day_data['day']))\n",
    "    \n",
    "    return (student_course_matching, lab_time_data, day_mapping, \n",
    "            pre_lab_ele_man_data, theory_time_data, course_data)\n",
    "\n",
    "def check_time_conflict(day1, start1, end1, day2, start2, end2):\n",
    "    \"\"\"\n",
    "    Check if two time slots conflict with each other.\n",
    "    \n",
    "    Args:\n",
    "        day1, day2: Days to compare\n",
    "        start1, end1: Start and end times for first slot\n",
    "        start2, end2: Start and end times for second slot\n",
    "        \n",
    "    Returns:\n",
    "        True if there's a conflict, False otherwise\n",
    "    \"\"\"\n",
    "    # If different days, no conflict\n",
    "    if day1 != day2:\n",
    "        return False\n",
    "    \n",
    "    # Convert times to integers for comparison\n",
    "    try:\n",
    "        start1 = int(start1)\n",
    "        end1 = int(end1)\n",
    "        start2 = int(start2)\n",
    "        end2 = int(end2)\n",
    "        \n",
    "        # Check for overlap\n",
    "        # No conflict if one ends before or at the same time the other starts \n",
    "        if end1 <= start2 or end2 <= start1:\n",
    "            return False\n",
    "            \n",
    "        # Otherwise, there's a conflict\n",
    "        return True\n",
    "    except ValueError:\n",
    "        # If conversion fails, assume no conflict\n",
    "        return False\n",
    "\n",
    "def optimize_lab_matching():\n",
    "    \"\"\"\n",
    "    Optimize lab matching for students based on course matching and preferences\n",
    "    \"\"\"\n",
    "    # Load data\n",
    "    (student_course_matching, lab_time_data, day_mapping, \n",
    "     pre_lab_ele_man_data, theory_time_data, course_data) = load_data()\n",
    "    \n",
    "    # Print initial data for debugging\n",
    "    print(\"Initial Data Analysis:\")\n",
    "    print(\"Total students in course matching:\", len(student_course_matching['student_id'].unique()))\n",
    "    print(\"Total lab time entries:\", len(lab_time_data))\n",
    "    \n",
    "    # Prepare the optimization model with more relaxed constraints\n",
    "    model = pulp.LpProblem(\"Lab_Matching\", pulp.LpMaximize)\n",
    "    \n",
    "    # Create utility calculation function\n",
    "    def calculate_utility(rank):\n",
    "        return max(10 - rank, 1)\n",
    "    \n",
    "    # Prepare necessary data structures\n",
    "    students = student_course_matching['student_id'].unique()\n",
    "    \n",
    "    # Prepare lab sections for courses with labs\n",
    "    lab_time_data['lab_id'] = lab_time_data.apply(\n",
    "        lambda x: f\"{x['course_id']}-{x['lab']}\", axis=1\n",
    "    )\n",
    "    \n",
    "    # Decision variables\n",
    "    # Y[s,l] = 1 if student s is assigned to lab section l, 0 otherwise\n",
    "    Y = pulp.LpVariable.dicts(\"Y\", \n",
    "        [(s, l) for s in students for l in lab_time_data['lab_id']], \n",
    "        cat=pulp.LpBinary\n",
    "    )\n",
    "    \n",
    "    # Calculate lab preference utility\n",
    "    lab_utility = []\n",
    "    for _, pref in pre_lab_ele_man_data.iterrows():\n",
    "        student_id = pref['student_id']\n",
    "        course_id = pref['course_id']\n",
    "        lab_num = pref['lab']\n",
    "        lab_id = f\"{course_id}-{lab_num}\"\n",
    "        \n",
    "        # Check if the student is taking this course and it has a lab\n",
    "        course_match = student_course_matching[\n",
    "            (student_course_matching['student_id'] == student_id) & \n",
    "            (student_course_matching['course_id'] == course_id)\n",
    "        ]\n",
    "        \n",
    "        # Check if the course has a lab\n",
    "        course_has_lab = course_data[\n",
    "            (course_data['course_id'] == course_id) & \n",
    "            (course_data['has_lab'] == 1)\n",
    "        ]\n",
    "        \n",
    "        if not course_match.empty and not course_has_lab.empty and lab_id in lab_time_data['lab_id'].values:\n",
    "            utility = calculate_utility(pref['preference_rank'])\n",
    "            lab_utility.append(utility * Y[(student_id, lab_id)])\n",
    "    \n",
    "    # Set objective: maximize lab preference utility\n",
    "    model += pulp.lpSum(lab_utility), \"Lab Preference Utility\"\n",
    "    \n",
    "    # Constraints\n",
    "    # 1. Lab assignment constraints for courses with labs\n",
    "    for student_id in students:\n",
    "        # Get courses for this student\n",
    "        student_courses = student_course_matching[\n",
    "            student_course_matching['student_id'] == student_id\n",
    "        ]\n",
    "        \n",
    "        for _, course in student_courses.iterrows():\n",
    "            # Check if course has a lab\n",
    "            course_has_lab = course_data[\n",
    "                (course_data['course_id'] == course['course_id']) & \n",
    "                (course_data['has_lab'] == 1)\n",
    "            ]\n",
    "            \n",
    "            if not course_has_lab.empty:\n",
    "                # Find possible lab sections for this course\n",
    "                possible_labs = lab_time_data[\n",
    "                    lab_time_data['course_id'] == course['course_id']\n",
    "                ]\n",
    "                \n",
    "                # Create lab IDs\n",
    "                course_lab_ids = [\n",
    "                    f\"{course['course_id']}-{lab['lab']}\" \n",
    "                    for _, lab in possible_labs.iterrows()\n",
    "                ]\n",
    "                \n",
    "                # If the course has a lab, student must be assigned exactly one lab\n",
    "                model += pulp.lpSum(Y[(student_id, l)] for l in course_lab_ids) == 1, \\\n",
    "                    f\"LabAssignment_{student_id}_{course['course_id']}\"\n",
    "    \n",
    "    # 2. Lab time conflict constraints\n",
    "    lab_time_conflicts = []\n",
    "    \n",
    "    # Check for conflicts between lab times\n",
    "    for student_id in students:\n",
    "        # Get courses for this student with labs\n",
    "        student_courses_with_labs = student_course_matching[\n",
    "            (student_course_matching['student_id'] == student_id) & \n",
    "            (student_course_matching['course_id'].isin(\n",
    "                course_data[course_data['has_lab'] == 1]['course_id']\n",
    "            ))\n",
    "        ]\n",
    "        \n",
    "        # Get lab times for this student's courses\n",
    "        lab_schedules = []\n",
    "        for _, course in student_courses_with_labs.iterrows():\n",
    "            # Find lab times for this course\n",
    "            course_labs = lab_time_data[lab_time_data['course_id'] == course['course_id']]\n",
    "            \n",
    "            for _, lab in course_labs.iterrows():\n",
    "                lab_schedules.append({\n",
    "                    'course_id': lab['course_id'],\n",
    "                    'lab': lab['lab'],\n",
    "                    'day': day_mapping.get(lab['id_day'], 'Unknown'),\n",
    "                    'start_time': lab['start_time'],\n",
    "                    'end_time': lab['end_time']\n",
    "                })\n",
    "        \n",
    "        # Check for conflicts between all lab pairs\n",
    "        for i in range(len(lab_schedules)):\n",
    "            for j in range(i+1, len(lab_schedules)):\n",
    "                lab1 = lab_schedules[i]\n",
    "                lab2 = lab_schedules[j]\n",
    "                \n",
    "                if check_time_conflict(\n",
    "                    lab1['day'], lab1['start_time'], lab1['end_time'],\n",
    "                    lab2['day'], lab2['start_time'], lab2['end_time']\n",
    "                ):\n",
    "                    lab_id1 = f\"{lab1['course_id']}-{lab1['lab']}\"\n",
    "                    lab_id2 = f\"{lab2['course_id']}-{lab2['lab']}\"\n",
    "                    lab_time_conflicts.append((student_id, lab_id1, lab_id2))\n",
    "    \n",
    "    # Add constraints to prevent lab time conflicts\n",
    "    for student_id, lab_id1, lab_id2 in lab_time_conflicts:\n",
    "        model += Y[(student_id, lab_id1)] + Y[(student_id, lab_id2)] <= 1, \\\n",
    "            f\"LabTimeConflict_{student_id}_{lab_id1}_{lab_id2}\"\n",
    "    \n",
    "    # Solve the model\n",
    "    model.solve()\n",
    "    \n",
    "    # Print solver status and details\n",
    "    print(\"\\nSolver Status:\", pulp.LpStatus[model.status])\n",
    "    \n",
    "    # Check solution status\n",
    "    if pulp.LpStatus[model.status] not in ['Optimal', 'Feasible']:\n",
    "        print(\"Could not find a solution. Analyzing potential issues...\")\n",
    "        return None\n",
    "    \n",
    "    # Prepare results\n",
    "    results = []\n",
    "    for student_id in students:\n",
    "        # Get student's courses\n",
    "        student_courses = student_course_matching[\n",
    "            student_course_matching['student_id'] == student_id\n",
    "        ]\n",
    "        \n",
    "        # Find student's name\n",
    "        student_name = student_courses['student_name'].iloc[0]\n",
    "        \n",
    "        for _, course in student_courses.iterrows():\n",
    "            # Find corresponding theory time\n",
    "            theory_time = theory_time_data[theory_time_data['course_id'] == course['course_id']]\n",
    "            \n",
    "            # Prepare lab information\n",
    "            lab_day = 'N/A'\n",
    "            lab_start_time = 'N/A'\n",
    "            lab_end_time = 'N/A'\n",
    "            \n",
    "            # Check if course has a lab\n",
    "            course_info = course_data[course_data['course_id'] == course['course_id']]\n",
    "            has_lab = course_info['has_lab'].iloc[0] if not course_info.empty else 0\n",
    "            \n",
    "            # If course has a lab, find lab information\n",
    "            if has_lab == 1:\n",
    "                # Find lab times for this course\n",
    "                course_labs = lab_time_data[lab_time_data['course_id'] == course['course_id']]\n",
    "                \n",
    "                for _, lab in course_labs.iterrows():\n",
    "                    lab_id = f\"{lab['course_id']}-{lab['lab']}\"\n",
    "                    \n",
    "                    # Check if this lab is assigned to the student\n",
    "                    if Y[(student_id, lab_id)].value() > 0.5:\n",
    "                        lab_day = day_mapping.get(lab['id_day'], 'Unknown')\n",
    "                        lab_start_time = lab['start_time']\n",
    "                        lab_end_time = lab['end_time']\n",
    "                        break\n",
    "            \n",
    "            # Append result for this course\n",
    "            results.append({\n",
    "                'student_id': student_id,\n",
    "                'student_name': student_name,\n",
    "                'course_id': course['course_id'],\n",
    "                'course_name': course['course_name'],\n",
    "                'course_type': course['course_type'],\n",
    "                'theory_day': day_mapping.get(theory_time['id_day'].iloc[0], 'Unknown') if not theory_time.empty else 'N/A',\n",
    "                'theory_start_time': theory_time['start_time'].iloc[0] if not theory_time.empty else 'N/A',\n",
    "                'theory_end_time': theory_time['end_time'].iloc[0] if not theory_time.empty else 'N/A',\n",
    "                'lab_day': lab_day,\n",
    "                'lab_start_time': lab_start_time,\n",
    "                'lab_end_time': lab_end_time\n",
    "            })\n",
    "    \n",
    "    # Convert to DataFrame and export\n",
    "    results_df = pd.DataFrame(results)\n",
    "    results_df.to_csv('student_lab_matching.csv', index=False)\n",
    "    \n",
    "    print(\"Course matching completed. Results saved to student_lab_matching.csv\")\n",
    "    return results_df\n",
    "\n",
    "def main():\n",
    "    # Run lab optimization\n",
    "    optimize_lab_matching()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72f23be3-2110-43b0-95b9-0cb4a96e8b38",
   "metadata": {},
   "source": [
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1e4e6e9e-333b-4be9-a931-858c7eed8ec2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Course matching completed using Gale-Shapley algorithm. Results saved to student_course_matching_gale_shapley.csv\n"
     ]
    }
   ],
   "source": [
    "def load_data():\n",
    "    \"\"\"Load necessary CSV files for course matching.\"\"\"\n",
    "    # Load CSV files\n",
    "    course_data = pd.read_csv('course.csv')\n",
    "    student_data = pd.read_csv('student.csv')\n",
    "    elective_capacity_data = pd.read_csv('elective_capacity.csv')\n",
    "    elective_preference_data = pd.read_csv('elective_preference.csv')\n",
    "    \n",
    "    # Strip whitespace from column names\n",
    "    course_data.columns = course_data.columns.str.strip()\n",
    "    student_data.columns = student_data.columns.str.strip()\n",
    "    elective_capacity_data.columns = elective_capacity_data.columns.str.strip()\n",
    "    elective_preference_data.columns = elective_preference_data.columns.str.strip()\n",
    "    \n",
    "    # Strip whitespace from string columns\n",
    "    for df in [course_data, student_data, elective_capacity_data, elective_preference_data]:\n",
    "        for col in df.select_dtypes(include=['object']).columns:\n",
    "            df[col] = df[col].str.strip()\n",
    "    \n",
    "    return course_data, student_data, elective_capacity_data, elective_preference_data\n",
    "\n",
    "def gale_shapley_course_matching():\n",
    "    \"\"\"\n",
    "    Optimize course matching for students using Gale-Shapley algorithm\n",
    "    with Preference Strength Priority for courses.\n",
    "    \"\"\"\n",
    "    # Load data\n",
    "    course_data, student_data, elective_capacity_data, elective_preference_data = load_data()\n",
    "    \n",
    "    # Create a result container\n",
    "    results = []\n",
    "    \n",
    "    # First, assign all mandatory courses\n",
    "    for _, student in student_data.iterrows():\n",
    "        student_id = student['student_id']\n",
    "        program_id = student['program_id']\n",
    "        \n",
    "        # Identify mandatory courses for this student's program\n",
    "        mandatory_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 1)\n",
    "        ]\n",
    "        \n",
    "        # Assign all mandatory courses\n",
    "        for _, course in mandatory_courses.iterrows():\n",
    "            results.append({\n",
    "                'student_id': student_id,\n",
    "                'student_name': student['name'],\n",
    "                'course_type': 'Mandatory',\n",
    "                'course_id': course['course_id'],\n",
    "                'course_name': course['course_name']\n",
    "            })\n",
    "    \n",
    "    # Now, handle elective courses using Gale-Shapley\n",
    "    \n",
    "    # 1. Calculate preference priority scores\n",
    "    # Find the maximum preference rank in the data\n",
    "    max_rank = elective_preference_data['preference_rank'].max()\n",
    "    \n",
    "    # Create a priority lookup dictionary\n",
    "    priority_lookup = {}\n",
    "    for _, pref in elective_preference_data.iterrows():\n",
    "        student_id = pref['student_id']\n",
    "        course_id = pref['course_id']\n",
    "        rank = pref['preference_rank']\n",
    "        \n",
    "        # Calculate priority score (higher for better preferences)\n",
    "        priority = (max_rank + 1) - rank\n",
    "        \n",
    "        # Store in lookup dictionary\n",
    "        priority_lookup[(course_id, student_id)] = priority\n",
    "    \n",
    "    # 2. Prepare data structures for Gale-Shapley\n",
    "    \n",
    "    # Create list of students who need electives\n",
    "    students_needing_electives = []\n",
    "    for _, student in student_data.iterrows():\n",
    "        student_id = student['student_id']\n",
    "        required_electives = student['required_electives']\n",
    "        \n",
    "        if required_electives > 0:\n",
    "            students_needing_electives.append({\n",
    "                'student_id': student_id,\n",
    "                'program_id': student['program_id'],\n",
    "                'required_electives': required_electives,\n",
    "                'assigned_electives': 0\n",
    "            })\n",
    "    \n",
    "    # Create preference lists for each student\n",
    "    student_preferences = {}\n",
    "    for student in students_needing_electives:\n",
    "        student_id = student['student_id']\n",
    "        program_id = student['program_id']\n",
    "        \n",
    "        # Get eligible elective courses for this student's program\n",
    "        eligible_courses = course_data[\n",
    "            (course_data['program_id'] == program_id) & \n",
    "            (course_data['mandatory'] == 0)\n",
    "        ]['course_id'].tolist()\n",
    "        \n",
    "        # Get and sort this student's preferences\n",
    "        student_prefs = elective_preference_data[\n",
    "            (elective_preference_data['student_id'] == student_id) & \n",
    "            (elective_preference_data['course_id'].isin(eligible_courses))\n",
    "        ].sort_values('preference_rank')\n",
    "        \n",
    "        # Create ordered preference list\n",
    "        student_preferences[student_id] = student_prefs['course_id'].tolist()\n",
    "    \n",
    "    # Initialize course capacities\n",
    "    course_capacities = {}\n",
    "    for _, capacity in elective_capacity_data.iterrows():\n",
    "        course_capacities[capacity['course_id']] = capacity['capacity']\n",
    "    \n",
    "    # Initialize assignment trackers\n",
    "    course_assignments = defaultdict(list)  # course_id -> list of assigned student_ids\n",
    "    student_assignments = defaultdict(list)  # student_id -> list of assigned course_ids\n",
    "    \n",
    "    # 3. Run Gale-Shapley algorithm\n",
    "    \n",
    "    # Create a queue of unmatched students\n",
    "    unmatched_students = [s['student_id'] for s in students_needing_electives]\n",
    "    \n",
    "    # Track which courses each student has already proposed to\n",
    "    proposed_to = defaultdict(set)\n",
    "    \n",
    "    # Continue until all students have their required number of electives or no more matches possible\n",
    "    while unmatched_students:\n",
    "        student_id = unmatched_students.pop(0)\n",
    "        \n",
    "        # Find the student's data\n",
    "        student_data_row = next(s for s in students_needing_electives if s['student_id'] == student_id)\n",
    "        \n",
    "        # Check if student has reached their required number of electives\n",
    "        if student_data_row['assigned_electives'] >= student_data_row['required_electives']:\n",
    "            continue\n",
    "        \n",
    "        # Get this student's preference list\n",
    "        preferences = student_preferences.get(student_id, [])\n",
    "        \n",
    "        # Find next preferred course that hasn't been proposed to yet\n",
    "        next_preferences = [c for c in preferences if c not in proposed_to[student_id]]\n",
    "        \n",
    "        if not next_preferences:\n",
    "            # Student has no more preferences but still needs electives\n",
    "            continue\n",
    "        \n",
    "        # Get next preferred course\n",
    "        course_id = next_preferences[0]\n",
    "        proposed_to[student_id].add(course_id)\n",
    "        \n",
    "        # Check if course has available capacity\n",
    "        if len(course_assignments[course_id]) < course_capacities.get(course_id, 0):\n",
    "            # Course has space, assign student\n",
    "            course_assignments[course_id].append(student_id)\n",
    "            student_assignments[student_id].append(course_id)\n",
    "            student_data_row['assigned_electives'] += 1\n",
    "            \n",
    "            # Put student back in queue if they need more electives\n",
    "            if student_data_row['assigned_electives'] < student_data_row['required_electives']:\n",
    "                unmatched_students.append(student_id)\n",
    "        else:\n",
    "            # Course is full, check if this student has higher priority than any current assignee\n",
    "            current_assignees = course_assignments[course_id]\n",
    "            \n",
    "            # Calculate priorities for all students (current + new)\n",
    "            all_students = current_assignees + [student_id]\n",
    "            priorities = [(s, priority_lookup.get((course_id, s), 0)) for s in all_students]\n",
    "            \n",
    "            # Sort by priority (higher priority first)\n",
    "            priorities.sort(key=lambda x: x[1], reverse=True)\n",
    "            \n",
    "            # Take top N students where N is the course capacity\n",
    "            capacity = course_capacities.get(course_id, 0)\n",
    "            selected_students = [s for s, _ in priorities[:capacity]]\n",
    "            \n",
    "            if student_id in selected_students:\n",
    "                # This student gets a spot\n",
    "                # Find the student who gets bumped (if any)\n",
    "                bumped_students = [s for s in current_assignees if s not in selected_students]\n",
    "                \n",
    "                # Update assignments\n",
    "                course_assignments[course_id] = selected_students\n",
    "                student_assignments[student_id].append(course_id)\n",
    "                student_data_row['assigned_electives'] += 1\n",
    "                \n",
    "                # Put student back in queue if they need more electives\n",
    "                if student_data_row['assigned_electives'] < student_data_row['required_electives']:\n",
    "                    unmatched_students.append(student_id)\n",
    "                \n",
    "                # Put bumped students back in queue\n",
    "                for bumped in bumped_students:\n",
    "                    # Find the bumped student's data\n",
    "                    bumped_data = next(s for s in students_needing_electives if s['student_id'] == bumped)\n",
    "                    \n",
    "                    # Remove the course from their assignments\n",
    "                    student_assignments[bumped].remove(course_id)\n",
    "                    bumped_data['assigned_electives'] -= 1\n",
    "                    \n",
    "                    # Add them back to the queue\n",
    "                    unmatched_students.append(bumped)\n",
    "            else:\n",
    "                # Student didn't get a spot, put them back in queue\n",
    "                unmatched_students.append(student_id)\n",
    "    \n",
    "    # 4. Add elective assignments to results\n",
    "    for student_id, courses in student_assignments.items():\n",
    "        student_name = student_data[student_data['student_id'] == student_id]['name'].iloc[0]\n",
    "        \n",
    "        for course_id in courses:\n",
    "            course_name = course_data[course_data['course_id'] == course_id]['course_name'].iloc[0]\n",
    "            \n",
    "            results.append({\n",
    "                'student_id': student_id,\n",
    "                'student_name': student_name,\n",
    "                'course_type': 'Elective',\n",
    "                'course_id': course_id,\n",
    "                'course_name': course_name\n",
    "            })\n",
    "    \n",
    "    # Convert to DataFrame and export\n",
    "    results_df = pd.DataFrame(results)\n",
    "    \n",
    "    # Sort results by student_id and then by course_type (Mandatory first, then Elective)\n",
    "    # First create a temporary column for sorting course_type\n",
    "    results_df['course_type_order'] = results_df['course_type'].apply(lambda x: 0 if x == 'Mandatory' else 1)\n",
    "    results_df = results_df.sort_values(by=['student_id', 'course_type_order'])\n",
    "    results_df = results_df.drop('course_type_order', axis=1)  # Remove temporary column\n",
    "    \n",
    "    results_df.to_csv('student_course_matching_gale_shapley.csv', index=False)\n",
    "    \n",
    "    print(\"Course matching completed using Gale-Shapley algorithm. Results saved to student_course_matching_gale_shapley.csv\")\n",
    "    return results_df\n",
    "\n",
    "def main():\n",
    "    # Run the Gale-Shapley optimization\n",
    "    gale_shapley_course_matching()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb98a983-979c-4ef6-ba66-8a77641c8b92",
   "metadata": {},
   "source": [
    "Overview of the Implementation\n",
    "\n",
    "Mandatory Course Assignment:\n",
    "\n",
    "First assigns all mandatory courses automatically, just like in your original code\n",
    "Only applies the matching algorithm to elective courses\n",
    "\n",
    "\n",
    "Preference Priority System:\n",
    "\n",
    "Calculates priority scores using the formula: priority = (max_rank + 1) - rank\n",
    "Creates a lookup dictionary for quick access to priority scores during matching\n",
    "\n",
    "\n",
    "Data Preparation:\n",
    "\n",
    "Builds preference lists for each student\n",
    "Tracks course capacities\n",
    "Only includes eligible courses for each student based on their program\n",
    "\n",
    "\n",
    "Gale-Shapley Algorithm:\n",
    "\n",
    "Maintains a queue of students who still need electives\n",
    "Students \"propose\" to courses in order of their preferences\n",
    "Courses accept students based on preference priorities\n",
    "If a course is full, it compares the new student with currently assigned students\n",
    "Students who need multiple electives can be re-added to the queue"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5dd60d3e-4b92-41b9-81a1-25b4ebe27323",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b39f2c1-3752-4b74-b5b9-c8e1cdae9a71",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initial Data Analysis:\n",
      "Total students in course matching: 7\n",
      "Total lab time entries: 18\n",
      "Lab matching completed using Gale-Shapley algorithm. Results saved to student_lab_matching_gale_shapley.csv\n"
     ]
    }
   ],
   "source": [
    "def load_data():\n",
    "    \"\"\"\n",
    "    Load necessary data for lab matching optimization\n",
    "    \"\"\"\n",
    "    # Load CSV files\n",
    "    student_course_matching = pd.read_csv('student_course_matching_gale_shapley.csv')\n",
    "    lab_time_data = pd.read_csv('lab_time.csv')\n",
    "    day_data = pd.read_csv('day.csv')\n",
    "    pre_lab_ele_man_data = pd.read_csv('pre_lab_ele_man.csv')\n",
    "    theory_time_data = pd.read_csv('theory_time.csv')\n",
    "    course_data = pd.read_csv('course.csv')\n",
    "    \n",
    "    # Strip whitespace from column names and data\n",
    "    for df in [student_course_matching, lab_time_data, day_data, \n",
    "               pre_lab_ele_man_data, theory_time_data, course_data]:\n",
    "        df.columns = df.columns.str.strip()\n",
    "        for col in df.select_dtypes(include=['object']).columns:\n",
    "            df[col] = df[col].str.strip()\n",
    "    \n",
    "    # Create day mapping\n",
    "    day_mapping = dict(zip(day_data['id_day'], day_data['day']))\n",
    "    \n",
    "    return (student_course_matching, lab_time_data, day_mapping, \n",
    "            pre_lab_ele_man_data, theory_time_data, course_data)\n",
    "\n",
    "def check_time_conflict(day1, start1, end1, day2, start2, end2):\n",
    "    \"\"\"\n",
    "    Check if two time slots conflict with each other.\n",
    "    \n",
    "    Args:\n",
    "        day1, day2: Days to compare\n",
    "        start1, end1: Start and end times for first slot\n",
    "        start2, end2: Start and end times for second slot\n",
    "        \n",
    "    Returns:\n",
    "        True if there's a conflict, False otherwise\n",
    "    \"\"\"\n",
    "    # If different days, no conflict\n",
    "    if day1 != day2:\n",
    "        return False\n",
    "    \n",
    "    # Convert times to integers for comparison\n",
    "    try:\n",
    "        start1 = int(start1)\n",
    "        end1 = int(end1)\n",
    "        start2 = int(start2)\n",
    "        end2 = int(end2)\n",
    "        \n",
    "        # Check for overlap\n",
    "        # No conflict if one ends before or at the same time the other starts \n",
    "        if end1 <= start2 or end2 <= start1:\n",
    "            return False\n",
    "            \n",
    "        # Otherwise, there's a conflict\n",
    "        return True\n",
    "    except ValueError:\n",
    "        # If conversion fails, assume no conflict\n",
    "        return False\n",
    "\n",
    "def gale_shapley_lab_matching():\n",
    "    \"\"\"\n",
    "    Optimize lab matching for students using Gale-Shapley algorithm\n",
    "    \"\"\"\n",
    "    # Load data\n",
    "    (student_course_matching, lab_time_data, day_mapping, \n",
    "     pre_lab_ele_man_data, theory_time_data, course_data) = load_data()\n",
    "    \n",
    "    print(\"Initial Data Analysis:\")\n",
    "    print(\"Total students in course matching:\", len(student_course_matching['student_id'].unique()))\n",
    "    print(\"Total lab time entries:\", len(lab_time_data))\n",
    "    \n",
    "    # Prepare necessary data structures\n",
    "    students = student_course_matching['student_id'].unique()\n",
    "    \n",
    "    # Prepare lab sections for courses with labs\n",
    "    lab_time_data['lab_id'] = lab_time_data.apply(\n",
    "        lambda x: f\"{x['course_id']}-{x['lab']}\", axis=1\n",
    "    )\n",
    "    \n",
    "    # Calculate lab preference utility and create student preference lists\n",
    "    # Find the maximum preference rank \n",
    "    \n",
    "    max_rank = pre_lab_ele_man_data['preference_rank'].max() if not pre_lab_ele_man_data.empty else 5\n",
    "    \n",
    "    # Create a priority lookup dictionary\n",
    "    priority_lookup = {}\n",
    "    for _, pref in pre_lab_ele_man_data.iterrows():\n",
    "        student_id = pref['student_id']\n",
    "        course_id = pref['course_id']\n",
    "        lab_num = pref['lab']\n",
    "        lab_id = f\"{course_id}-{lab_num}\"\n",
    "        rank = pref['preference_rank']\n",
    "        \n",
    "        # Calculate priority score (higher for better preferences)\n",
    "        priority = (max_rank + 1) - rank\n",
    "        \n",
    "        # Store in lookup dictionary\n",
    "        priority_lookup[(lab_id, student_id)] = priority\n",
    "    \n",
    "    # Create student preferences for labs\n",
    "    student_preferences = defaultdict(dict)  # student_id -> {course_id -> [lab_ids]}\n",
    "    \n",
    "    for student_id in students:\n",
    "        # Get courses for this student\n",
    "        student_courses = student_course_matching[\n",
    "            student_course_matching['student_id'] == student_id\n",
    "        ]\n",
    "        \n",
    "        for _, course in student_courses.iterrows():\n",
    "            course_id = course['course_id']\n",
    "            \n",
    "            # Check if course has a lab\n",
    "            course_has_lab = course_data[\n",
    "                (course_data['course_id'] == course_id) & \n",
    "                (course_data['has_lab'] == 1)\n",
    "            ]\n",
    "            \n",
    "            if not course_has_lab.empty:\n",
    "                # Find possible lab sections for this course\n",
    "                possible_labs = lab_time_data[\n",
    "                    lab_time_data['course_id'] == course_id\n",
    "                ]\n",
    "                \n",
    "                # Create lab IDs\n",
    "                course_lab_ids = [\n",
    "                    f\"{course_id}-{lab['lab']}\" \n",
    "                    for _, lab in possible_labs.iterrows()\n",
    "                ]\n",
    "                \n",
    "                # Get student preferences for this course's labs\n",
    "                student_prefs = pre_lab_ele_man_data[\n",
    "                    (pre_lab_ele_man_data['student_id'] == student_id) & \n",
    "                    (pre_lab_ele_man_data['course_id'] == course_id)\n",
    "                ]\n",
    "                \n",
    "                # Create preference list for this course\n",
    "                if not student_prefs.empty:\n",
    "                    # Use student's preferences\n",
    "                    lab_prefs = student_prefs.sort_values('preference_rank')\n",
    "                    preferred_lab_ids = [\n",
    "                        f\"{course_id}-{lab['lab']}\" \n",
    "                        for _, lab in lab_prefs.iterrows()\n",
    "                    ]\n",
    "                    \n",
    "                    # Add any remaining labs not in preferences\n",
    "                    for lab_id in course_lab_ids:\n",
    "                        if lab_id not in preferred_lab_ids:\n",
    "                            preferred_lab_ids.append(lab_id)\n",
    "                else:\n",
    "                    # If no preferences, use all labs in arbitrary order\n",
    "                    preferred_lab_ids = course_lab_ids\n",
    "                \n",
    "                # Store preference list for this course\n",
    "                student_preferences[student_id][course_id] = preferred_lab_ids\n",
    "    \n",
    "    # Track lab assignments and capacities\n",
    "    lab_assignments = defaultdict(list)  # lab_id -> list of assigned student_ids\n",
    "    student_lab_assignments = defaultdict(dict)  # student_id -> {course_id -> lab_id}\n",
    "    \n",
    "    # Initialize lab capacities (assuming each lab has a capacity)\n",
    "    lab_capacities = {}\n",
    "    for _, lab in lab_time_data.iterrows():\n",
    "        lab_id = f\"{lab['course_id']}-{lab['lab']}\"\n",
    "        # Assume equal capacity for all lab sections\n",
    "        # This can be adjusted if actual capacities are available\n",
    "        lab_capacities[lab_id] = 30  # Default capacity\n",
    "    \n",
    "    # Identify courses with labs for each student\n",
    "    courses_with_labs = {}\n",
    "    for student_id in students:\n",
    "        # Get courses for this student\n",
    "        student_courses = student_course_matching[\n",
    "            student_course_matching['student_id'] == student_id\n",
    "        ]\n",
    "        \n",
    "        # Filter to courses with labs\n",
    "        lab_courses = []\n",
    "        for _, course in student_courses.iterrows():\n",
    "            course_has_lab = course_data[\n",
    "                (course_data['course_id'] == course['course_id']) & \n",
    "                (course_data['has_lab'] == 1)\n",
    "            ]\n",
    "            \n",
    "            if not course_has_lab.empty:\n",
    "                lab_courses.append(course['course_id'])\n",
    "        \n",
    "        courses_with_labs[student_id] = lab_courses\n",
    "    \n",
    "    # Create a queue of unmatched students for each course with a lab\n",
    "    unmatched_queue = []\n",
    "    for student_id, course_ids in courses_with_labs.items():\n",
    "        for course_id in course_ids:\n",
    "            unmatched_queue.append((student_id, course_id))\n",
    "    \n",
    "    # Track which labs each student has proposed to for each course\n",
    "    proposed_to = defaultdict(lambda: defaultdict(set))  # student_id -> {course_id -> set of lab_ids}\n",
    "    \n",
    "    # Run Gale-Shapley algorithm for lab matching\n",
    "    while unmatched_queue:\n",
    "        student_id, course_id = unmatched_queue.pop(0)\n",
    "        \n",
    "        # Check if student already has a lab assignment for this course\n",
    "        if course_id in student_lab_assignments[student_id]:\n",
    "            continue\n",
    "        \n",
    "        # Get student's preference list for this course\n",
    "        preferences = student_preferences[student_id].get(course_id, [])\n",
    "        \n",
    "        # Find next preferred lab that hasn't been proposed to\n",
    "        next_labs = [lab_id for lab_id in preferences if lab_id not in proposed_to[student_id][course_id]]\n",
    "        \n",
    "        if not next_labs:\n",
    "            # Student has proposed to all labs but still unmatched - this is a problem\n",
    "            print(f\"Warning: Student {student_id} has no more lab preferences for course {course_id}\")\n",
    "            continue\n",
    "        \n",
    "        # Get next preferred lab\n",
    "        lab_id = next_labs[0]\n",
    "        proposed_to[student_id][course_id].add(lab_id)\n",
    "        \n",
    "        # Check for time conflicts with other assigned labs\n",
    "        has_conflict = False\n",
    "        lab_info = lab_time_data[lab_time_data['lab_id'] == lab_id].iloc[0]\n",
    "        lab_day = day_mapping.get(lab_info['id_day'], 'Unknown')\n",
    "        lab_start = lab_info['start_time']\n",
    "        lab_end = lab_info['end_time']\n",
    "        \n",
    "        for other_course_id, assigned_lab_id in student_lab_assignments[student_id].items():\n",
    "            other_lab_info = lab_time_data[lab_time_data['lab_id'] == assigned_lab_id].iloc[0]\n",
    "            other_day = day_mapping.get(other_lab_info['id_day'], 'Unknown')\n",
    "            other_start = other_lab_info['start_time']\n",
    "            other_end = other_lab_info['end_time']\n",
    "            \n",
    "            if check_time_conflict(lab_day, lab_start, lab_end, other_day, other_start, other_end):\n",
    "                has_conflict = True\n",
    "                break\n",
    "        \n",
    "        if has_conflict:\n",
    "            # Put student back in queue for this course\n",
    "            unmatched_queue.append((student_id, course_id))\n",
    "            continue\n",
    "        \n",
    "        # Check if lab has available capacity\n",
    "        if len(lab_assignments[lab_id]) < lab_capacities.get(lab_id, 0):\n",
    "            # Lab has space, assign student\n",
    "            lab_assignments[lab_id].append(student_id)\n",
    "            student_lab_assignments[student_id][course_id] = lab_id\n",
    "        else:\n",
    "            # Lab is at capacity, check if this student has higher priority than any current assignee\n",
    "            current_assignees = lab_assignments[lab_id]\n",
    "            \n",
    "            # Calculate priorities\n",
    "            all_students = current_assignees + [student_id]\n",
    "            priorities = [(s, priority_lookup.get((lab_id, s), 0)) for s in all_students]\n",
    "            \n",
    "            # Sort by priority (higher priority first) and break ties by student_id\n",
    "            priorities.sort(key=lambda x: (x[1], x[0]), reverse=True)\n",
    "            \n",
    "            # Take top N students where N is the lab capacity\n",
    "            capacity = lab_capacities.get(lab_id, 0)\n",
    "            selected_students = [s for s, _ in priorities[:capacity]]\n",
    "            \n",
    "            if student_id in selected_students:\n",
    "                # This student gets a spot\n",
    "                # Find the student who gets bumped (if any)\n",
    "                bumped_students = [s for s in current_assignees if s not in selected_students]\n",
    "                \n",
    "                # Update assignments\n",
    "                lab_assignments[lab_id] = selected_students\n",
    "                student_lab_assignments[student_id][course_id] = lab_id\n",
    "                \n",
    "                # Put bumped students back in queue for this course\n",
    "                for bumped in bumped_students:\n",
    "                    # Remove the lab from their assignment\n",
    "                    bumped_course = next((c for c, l in student_lab_assignments[bumped].items() if l == lab_id), None)\n",
    "                    if bumped_course:\n",
    "                        del student_lab_assignments[bumped][bumped_course]\n",
    "                        unmatched_queue.append((bumped, bumped_course))\n",
    "            else:\n",
    "                # Student didn't get a spot, put them back in queue\n",
    "                unmatched_queue.append((student_id, course_id))\n",
    "    \n",
    "    # Prepare results\n",
    "    results = []\n",
    "    for student_id in students:\n",
    "        # Get student's courses\n",
    "        student_courses = student_course_matching[\n",
    "            student_course_matching['student_id'] == student_id\n",
    "        ]\n",
    "        \n",
    "        # Find student's name\n",
    "        student_name = student_courses['student_name'].iloc[0]\n",
    "        \n",
    "        for _, course in student_courses.iterrows():\n",
    "            course_id = course['course_id']\n",
    "            \n",
    "            # Find corresponding theory time\n",
    "            theory_time = theory_time_data[theory_time_data['course_id'] == course_id]\n",
    "            \n",
    "            # Prepare lab information\n",
    "            lab_day = 'N/A'\n",
    "            lab_start_time = 'N/A'\n",
    "            lab_end_time = 'N/A'\n",
    "            \n",
    "            # Check if course has a lab\n",
    "            course_info = course_data[course_data['course_id'] == course_id]\n",
    "            has_lab = course_info['has_lab'].iloc[0] if not course_info.empty else 0\n",
    "            \n",
    "            # If course has a lab, find lab information\n",
    "            if has_lab == 1:\n",
    "                assigned_lab_id = student_lab_assignments[student_id].get(course_id)\n",
    "                \n",
    "                if assigned_lab_id:\n",
    "                    lab_info = lab_time_data[lab_time_data['lab_id'] == assigned_lab_id].iloc[0]\n",
    "                    lab_day = day_mapping.get(lab_info['id_day'], 'Unknown')\n",
    "                    lab_start_time = lab_info['start_time']\n",
    "                    lab_end_time = lab_info['end_time']\n",
    "            \n",
    "            # Append result for this course\n",
    "            results.append({\n",
    "                'student_id': student_id,\n",
    "                'student_name': student_name,\n",
    "                'course_id': course_id,\n",
    "                'course_name': course['course_name'],\n",
    "                'course_type': course['course_type'],\n",
    "                'theory_day': day_mapping.get(theory_time['id_day'].iloc[0], 'Unknown') if not theory_time.empty else 'N/A',\n",
    "                'theory_start_time': theory_time['start_time'].iloc[0] if not theory_time.empty else 'N/A',\n",
    "                'theory_end_time': theory_time['end_time'].iloc[0] if not theory_time.empty else 'N/A',\n",
    "                'lab_day': lab_day,\n",
    "                'lab_start_time': lab_start_time,\n",
    "                'lab_end_time': lab_end_time\n",
    "            })\n",
    "    \n",
    "    # Check for students who still need lab assignments\n",
    "    missing_labs = []\n",
    "    for student_id in students:\n",
    "        for course_id in courses_with_labs.get(student_id, []):\n",
    "            if course_id not in student_lab_assignments[student_id]:\n",
    "                missing_labs.append((student_id, course_id))\n",
    "    \n",
    "    if missing_labs:\n",
    "        print(f\"Warning: {len(missing_labs)} student-course pairs still need lab assignments\")\n",
    "        print(\"First few missing assignments:\", missing_labs[:5])\n",
    "    \n",
    "    # Convert to DataFrame and export\n",
    "    results_df = pd.DataFrame(results)\n",
    "    \n",
    "    # Sort results by student_id and then by course_id\n",
    "    results_df = results_df.sort_values(by=['student_id', 'course_id'])\n",
    "    \n",
    "    results_df.to_csv('student_lab_matching_gale_shapley.csv', index=False)\n",
    "    \n",
    "    print(\"Lab matching completed using Gale-Shapley algorithm. Results saved to student_lab_matching_gale_shapley.csv\")\n",
    "    return results_df\n",
    "\n",
    "def main():\n",
    "    # Run lab optimization using Gale-Shapley\n",
    "    gale_shapley_lab_matching()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aca2fe83-bffa-4f7b-b057-db4775451aae",
   "metadata": {},
   "source": [
    "Key Features of the Solution:\n",
    "\n",
    "Preference-Based Priority System:\n",
    "\n",
    "Uses student preferences for lab sections from the pre_lab_ele_man_data table\n",
    "Calculates priority scores based on preference rankings\n",
    "\n",
    "\n",
    "Multiple Constraint Handling:\n",
    "\n",
    "Lab Time Conflicts: Checks for conflicts between lab times before making assignments\n",
    "Course-Lab Association: Students are only assigned to labs for courses they're taking\n",
    "Lab Capacity: Ensures labs don't exceed capacity\n",
    "\n",
    "\n",
    "Modified Gale-Shapley Algorithm:\n",
    "\n",
    "Students \"propose\" to labs in order of their preferences\n",
    "Labs accept students based on priority scores with student ID as tie-breaker\n",
    "If a lab is full, it may bump lower-priority students\n",
    "\n",
    "\n",
    "Comprehensive Output:\n",
    "\n",
    "Includes theory and lab times for all courses\n",
    "Reports any students who couldn't be assigned to labs\n",
    "\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
